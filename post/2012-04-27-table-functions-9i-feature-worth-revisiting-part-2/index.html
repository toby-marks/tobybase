<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">

    <meta name="author" content="Toby Marks">
    <meta name="description" content="In part one of this series I showed a simple example of how table functions can be used to treat PL/SQL collection types as tables in a SQL query. We used a nested table collection type to which we manually added a few entries. In this example, I intend to show a more practical use of table functions using all three PL/SQL collection types: associative arrays, nested tables, and VARRAYs.">
    <meta name="keywords" content="oracle,infolob,blog,consultant,developer,tuning,exadata,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Table Functions: 9i Feature Worth Revisiting (Part 2)"/>
<meta name="twitter:description" content="In part one of this series I showed a simple example of how table functions can be used to treat PL/SQL collection types as tables in a SQL query. We used a nested table collection type to which we manually added a few entries. In this example, I intend to show a more practical use of table functions using all three PL/SQL collection types: associative arrays, nested tables, and VARRAYs."/>

    <meta property="og:title" content="Table Functions: 9i Feature Worth Revisiting (Part 2)" />
<meta property="og:description" content="In part one of this series I showed a simple example of how table functions can be used to treat PL/SQL collection types as tables in a SQL query. We used a nested table collection type to which we manually added a few entries. In this example, I intend to show a more practical use of table functions using all three PL/SQL collection types: associative arrays, nested tables, and VARRAYs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://tobybase.com/post/2012-04-27-table-functions-9i-feature-worth-revisiting-part-2/" />
<meta property="article:published_time" content="2012-04-27T22:35:00+00:00" />
<meta property="article:modified_time" content="2017-02-22T00:00:00+00:00" />



    
      <base href="http://tobybase.com/post/2012-04-27-table-functions-9i-feature-worth-revisiting-part-2/">
    
    <title>
  Table Functions: 9i Feature Worth Revisiting (Part 2) ¬∑ üë®üèª‚Äçüíª Tobybase
</title>

    
      <link rel="canonical" href="http://tobybase.com/post/2012-04-27-table-functions-9i-feature-worth-revisiting-part-2/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css" integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="http://tobybase.com/css/coder.min.a4f332213a21ce8eb521670c614470c58923aaaf385e2a73982c31dd7642decb.css" integrity="sha256-pPMyITohzo61IWcMYURwxYkjqq84XipzmCwx3XZC3ss=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://tobybase.com/css/custom.css" />
    

    

    <link rel="icon" type="image/png" href="http://tobybase.com/img/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://tobybase.com/img/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.71.0" />
  </head>

  
  
  <body class="colorscheme-light">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://tobybase.com/">
      üë®üèª‚Äçüíª Tobybase
    </a>
    
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://tobybase.com/post/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://tobybase.com/links/">Links</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://tobybase.com/about/">About</a>
          </li>
        
      
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>Table Functions: 9i Feature Worth Revisiting (Part 2)</h1>
    </header>

    <p>In <a href="http://tobybase.com/post/2012-04-27-table-functions-9i-feature-worth-revisiting-part-1/-1">part one of this series</a> I showed a simple example of how table functions can be used to treat PL/SQL collection types as tables in a SQL query. We used a nested table collection type to which we manually added a few entries. In this example, I intend to show a more practical use of table functions using all three PL/SQL collection types: associative arrays, nested tables, and VARRAYs.</p>
<p>Let&rsquo;s revisit a use case I alluded to in my earlier blog entry: incorporating LDAP data into a query. Suppose your task is to code a custom authorization scheme for an enterprise application reporting system. You want row access to be determined by a user&rsquo;s group memberships in the company&rsquo;s Active Directory server. If a user is assigned to &ldquo;the Company A group&rdquo; in Active Directory, he gets to see Company A&rsquo;s data. You can configure that kind of restriction at a database level using <a href="http://www.oracle.com/technetwork/database/security/index-088277.html">Oracle&rsquo;s Virtual Private Database</a> feature. Configuring VPD is beyond the scope of this blog entry, but ultimately you will be associating a table to a portion of a SQL WHERE clause that gets appended to every query written against that table. You can find more documentation on VPD <a href="http://download.oracle.com/docs/cd/B28359_01/network.111/b28531/vpd.htm">on the OTN site</a>. In this case, let&rsquo;s assume you know that another team has written a PL/SQL database package to query data from Active Directory, and you want to make use of that code. The only problem is that all the functions in that package return collections of various types, and you need to be able to access that information from the WHERE clause you are building with VPD. This is where table functions come in handy.</p>
<p>Let&rsquo;s begin by setting up our example schema. We&rsquo;ll be looking at client sales data. First, let&rsquo;s set up our clients.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">CREATE</span> <span style="font-weight:bold">TABLE</span> clients (
      client_id NUMBER,
      client_name VARCHAR2(50));

    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> clients <span style="font-weight:bold">VALUES</span> (100, <span style="font-style:italic">&#39;Timco Industries&#39;</span>);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> clients <span style="font-weight:bold">VALUES</span> (200, <span style="font-style:italic">&#39;Moneybros&#39;</span>);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> clients <span style="font-weight:bold">VALUES</span> (300, <span style="font-style:italic">&#39;The Monacle Corporation&#39;</span>);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> clients <span style="font-weight:bold">VALUES</span> (400, <span style="font-style:italic">&#39;Schmapple&#39;</span>);
</code></pre></div><p>We also need application users who will be logging in to view the report data. We&rsquo;ll assume each application user is uniquely linked to a user in Active Directory via the external_id column.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">CREATE</span> <span style="font-weight:bold">TABLE</span> users (
      sequence_number NUMBER,
      user_name VARCHAR2(20),
      external_id VARCHAR2(20),
      first_name VARCHAR2(30),
      last_name VARCHAR2(30));

    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> users <span style="font-weight:bold">VALUES</span> (1, <span style="font-style:italic">&#39;JACKA&#39;</span>, <span style="font-style:italic">&#39;jaugusti&#39;</span>, <span style="font-style:italic">&#39;Jack&#39;</span>, <span style="font-style:italic">&#39;Augustine&#39;</span>);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> users <span style="font-weight:bold">VALUES</span> (2, <span style="font-style:italic">&#39;KENKI&#39;</span>, <span style="font-style:italic">&#39;kkidd&#39;</span>, <span style="font-style:italic">&#39;Ken&#39;</span>, <span style="font-style:italic">&#39;Kidd&#39;</span>);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> users <span style="font-weight:bold">VALUES</span> (3, <span style="font-style:italic">&#39;BRIAH&#39;</span>, <span style="font-style:italic">&#39;bhill&#39;</span>, <span style="font-style:italic">&#39;Brian&#39;</span>, <span style="font-style:italic">&#39;Hill&#39;</span>);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> users <span style="font-weight:bold">VALUES</span> (4, <span style="font-style:italic">&#39;KEOVO&#39;</span>, <span style="font-style:italic">&#39;kvongkas&#39;</span>, <span style="font-style:italic">&#39;Keo&#39;</span>, <span style="font-style:italic">&#39;Vongkaseum&#39;</span>);
</code></pre></div><p>Finally, we need a data table on which to report.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">CREATE</span> <span style="font-weight:bold">TABLE</span> quarterly_sales_data (
      sequence_number NUMBER,
      client_id NUMBER,
      sales_year NUMBER,
      sales_quarter NUMBER,
      sales_amount NUMBER);

    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (1, 100, 2011, 1, 20000);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (2, 100, 2011, 2, 17500);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (3, 100, 2011, 3, 33000);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (4, 200, 2011, 1, 4500);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (5, 200, 2011, 2, 7000);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (6, 200, 2011, 3, 6300);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (7, 300, 2011, 1, 11100);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (8, 300, 2011, 2, 12800);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (9, 300, 2011, 3, 14000);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (10, 400, 2011, 1, 55600);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (11, 400, 2011, 2, 80000);
    <span style="font-weight:bold">INSERT</span> <span style="font-weight:bold">INTO</span> quarterly_sales_data <span style="font-weight:bold">VALUES</span> (12, 400, 2011, 3, 78500);
</code></pre></div><p>Our basic report query will look something like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">SELECT</span> client_name, sales_year, sales_quarter, sales_amount
      <span style="font-weight:bold">FROM</span> quarterly_sales_data <span style="font-weight:bold">NATURAL</span> <span style="font-weight:bold">JOIN</span> clients;
</code></pre></div><p>Our Active Directory groups will be TIMCO_GRP, MONEYBROS_GRP, MONACLE_GRP, and SCHMAPPLE_GRP. If a user belongs to one or more of these groups, he has permission to view the respective client&rsquo;s data.</p>
<p>Now we need a function that returns data from Active Directory. Just to keep it simple we will create a package that hardcodes the group memberships and returns them as collections of various types. We will then look at how table functions can be used to transform each one of those collections into an aggregate result set. (NOTE: querying LDAP directories from PL/SQL is not too difficult, and might serve as the basis for a future blog entry.)</p>
<p>Here&rsquo;s our function. We&rsquo;ve placed it in a package called LDAP_UTIL.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">    CREATE OR REPLACE PACKAGE ldap_util AS

      TYPE ldap_entry_typ IS RECORD (
        cn VARCHAR2(30),
        description VARCHAR2(1000),
        distinguished_name VARCHAR2(200),
        name VARCHAR2(30),
        samaccountname VARCHAR2(30));

      TYPE ldap_groups_nt IS TABLE OF ldap_entry_typ;
      TYPE ldap_groups_aa IS TABLE OF ldap_entry_typ INDEX BY PLS_INTEGER;
      TYPE ldap_groups_va IS VARRAY(100) of ldap_entry_typ;

      FUNCTION get_user_groups_nt (p_user VARCHAR2) RETURN ldap_groups_nt;
      FUNCTION get_user_groups_aa (p_user VARCHAR2) RETURN ldap_groups_aa;
      FUNCTION get_user_groups_va (p_user VARCHAR2) RETURN ldap_groups_va;

    END ldap_util;
    /
    SHOW ERRORS

    CREATE OR REPLACE PACKAGE BODY ldap_util AS

      FUNCTION get_user_groups_nt (p_user VARCHAR2) RETURN ldap_groups_nt IS
        l_groups ldap_groups_nt := ldap_groups_nt();
      BEGIN
        CASE p_user
          WHEN &#39;jaugusti&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;TIMCO_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Timco Industries account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=TIMCO_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;TIMCO_GRP&#39;;
            l_groups(1).samaccountname := &#39;TIMCO_GRP&#39;;

          WHEN &#39;kkidd&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Moneybros account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=MONEYBROS_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).samaccountname := &#39;MONEYBROS_GRP&#39;;

          WHEN &#39;bhill&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;TIMCO_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Timco Industries account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=TIMCO_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;TIMCO_GRP&#39;;
            l_groups(1).samaccountname := &#39;TIMCO_GRP&#39;;

            l_groups.extend;
            l_groups(2).cn := &#39;MONACLE_GRP&#39;;
            l_groups(2).description := &#39;Employees working on the Monacle Corporation account.&#39;;
            l_groups(2).distinguished_name := &#39;CN=MONACLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(2).name := &#39;MONACLE_GRP&#39;;
            l_groups(2).samaccountname := &#39;MONACLE_GRP&#39;;

          WHEN &#39;kvongkas&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Moneybros account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=MONEYBROS_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).samaccountname := &#39;MONEYBROS_GRP&#39;;

            l_groups.extend;
            l_groups(2).cn := &#39;MONACLE_GRP&#39;;
            l_groups(2).description := &#39;Employees working on the Monacle Corporation account.&#39;;
            l_groups(2).distinguished_name := &#39;CN=MONACLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(2).name := &#39;MONACLE_GRP&#39;;
            l_groups(2).samaccountname := &#39;MONACLE_GRP&#39;;

            l_groups.extend;
            l_groups(3).cn := &#39;SCHMAPPLE_GRP&#39;;
            l_groups(3).description := &#39;Employees working on the Schmapple account.&#39;;
            l_groups(3).distinguished_name := &#39;CN=SCHMAPPLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(3).name := &#39;SCHMAPPLE_GRP&#39;;
            l_groups(3).samaccountname := &#39;SCHMAPPLE_GRP&#39;;

        END CASE;
        RETURN l_groups;
      END get_user_groups_nt;

      FUNCTION get_user_groups_aa (p_user VARCHAR2) RETURN ldap_groups_aa IS
        l_groups ldap_groups_aa;
      BEGIN
        CASE p_user
          WHEN &#39;jaugusti&#39; THEN

            l_groups(1).cn := &#39;TIMCO_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Timco Industries account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=TIMCO_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;TIMCO_GRP&#39;;
            l_groups(1).samaccountname := &#39;TIMCO_GRP&#39;;

          WHEN &#39;kkidd&#39; THEN

            l_groups(1).cn := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Moneybros account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=MONEYBROS_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).samaccountname := &#39;MONEYBROS_GRP&#39;;

          WHEN &#39;bhill&#39; THEN

            l_groups(1).cn := &#39;TIMCO_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Timco Industries account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=TIMCO_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;TIMCO_GRP&#39;;
            l_groups(1).samaccountname := &#39;TIMCO_GRP&#39;;

            l_groups(2).cn := &#39;MONACLE_GRP&#39;;
            l_groups(2).description := &#39;Employees working on the Monacle Corporation account.&#39;;
            l_groups(2).distinguished_name := &#39;CN=MONACLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(2).name := &#39;MONACLE_GRP&#39;;
            l_groups(2).samaccountname := &#39;MONACLE_GRP&#39;;

          WHEN &#39;kvongkas&#39; THEN

            l_groups(1).cn := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Moneybros account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=MONEYBROS_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).samaccountname := &#39;MONEYBROS_GRP&#39;;

            l_groups(2).cn := &#39;MONACLE_GRP&#39;;
            l_groups(2).description := &#39;Employees working on the Monacle Corporation account.&#39;;
            l_groups(2).distinguished_name := &#39;CN=MONACLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(2).name := &#39;MONACLE_GRP&#39;;
            l_groups(2).samaccountname := &#39;MONACLE_GRP&#39;;

            l_groups(3).cn := &#39;SCHMAPPLE_GRP&#39;;
            l_groups(3).description := &#39;Employees working on the Schmapple account.&#39;;
            l_groups(3).distinguished_name := &#39;CN=SCHMAPPLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(3).name := &#39;SCHMAPPLE_GRP&#39;;
            l_groups(3).samaccountname := &#39;SCHMAPPLE_GRP&#39;;

        END CASE;
        RETURN l_groups;
      END get_user_groups_aa;

      FUNCTION get_user_groups_va (p_user VARCHAR2) RETURN ldap_groups_va IS
        l_groups ldap_groups_va := ldap_groups_va();
      BEGIN
        CASE p_user
          WHEN &#39;jaugusti&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;TIMCO_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Timco Industries account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=TIMCO_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;TIMCO_GRP&#39;;
            l_groups(1).samaccountname := &#39;TIMCO_GRP&#39;;

          WHEN &#39;kkidd&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Moneybros account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=MONEYBROS_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).samaccountname := &#39;MONEYBROS_GRP&#39;;

          WHEN &#39;bhill&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;TIMCO_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Timco Industries account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=TIMCO_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;TIMCO_GRP&#39;;
            l_groups(1).samaccountname := &#39;TIMCO_GRP&#39;;

            l_groups.extend;
            l_groups(2).cn := &#39;MONACLE_GRP&#39;;
            l_groups(2).description := &#39;Employees working on the Monacle Corporation account.&#39;;
            l_groups(2).distinguished_name := &#39;CN=MONACLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(2).name := &#39;MONACLE_GRP&#39;;
            l_groups(2).samaccountname := &#39;MONACLE_GRP&#39;;

          WHEN &#39;kvongkas&#39; THEN

            l_groups.extend;
            l_groups(1).cn := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).description := &#39;Employees working on the Moneybros account.&#39;;
            l_groups(1).distinguished_name := &#39;CN=MONEYBROS_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(1).name := &#39;MONEYBROS_GRP&#39;;
            l_groups(1).samaccountname := &#39;MONEYBROS_GRP&#39;;

            l_groups.extend;
            l_groups(2).cn := &#39;MONACLE_GRP&#39;;
            l_groups(2).description := &#39;Employees working on the Monacle Corporation account.&#39;;
            l_groups(2).distinguished_name := &#39;CN=MONACLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(2).name := &#39;MONACLE_GRP&#39;;
            l_groups(2).samaccountname := &#39;MONACLE_GRP&#39;;

            l_groups.extend;
            l_groups(3).cn := &#39;SCHMAPPLE_GRP&#39;;
            l_groups(3).description := &#39;Employees working on the Schmapple account.&#39;;
            l_groups(3).distinguished_name := &#39;CN=SCHMAPPLE_GRP,OU=Global Groups,DC=acme,DC=com&#39;;
            l_groups(3).name := &#39;SCHMAPPLE_GRP&#39;;
            l_groups(3).samaccountname := &#39;SCHMAPPLE_GRP&#39;;

        END CASE;
        RETURN l_groups;
      END get_user_groups_va;

    END ldap_util;
    /
    SHOW ERRORS
</code></pre></div><p>As you can see, LDAP_UTIL has three functions that return the three kinds of collections in PL/SQL: nested tables, associative arrays, and varrays.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">FUNCTION</span> get_user_groups_nt (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_groups_nt;
    <span style="font-weight:bold">FUNCTION</span> get_user_groups_aa (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_groups_aa;
    <span style="font-weight:bold">FUNCTION</span> get_user_groups_va (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_groups_va;
</code></pre></div><p>The collections consist of a group of records representing &ldquo;group&rdquo; data from Active Directory.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">TYPE</span> ldap_entry_typ <span style="font-weight:bold">IS</span> RECORD (
        cn VARCHAR2(30),
        description VARCHAR2(1000),
        distinguished_name VARCHAR2(200),
        name VARCHAR2(30),
        samaccountname VARCHAR2(30));
</code></pre></div><p>The p_user parameter would be the user&rsquo;s network id, corresponding to the sAMAccountName attribute in Active Directory; since we&rsquo;re hardcoding group data this is not important to us at the moment. The point is you pass in a username and you get a collection of groups.</p>
<p>Using the same technique we demonstrated in part one, we now create a wrapper package of pipelined functions to transform the collection data into something we can query - an aggregate result set.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">CREATE</span> <span style="font-weight:bold">OR</span> <span style="font-weight:bold">REPLACE</span> PACKAGE ldap_util_pipelined <span style="font-weight:bold">AS</span>

      <span style="font-weight:bold">FUNCTION</span> get_user_groups_nt (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_nt PIPELINED;
      <span style="font-weight:bold">FUNCTION</span> get_user_groups_aa (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_nt PIPELINED;
      <span style="font-weight:bold">FUNCTION</span> get_user_groups_va (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_va PIPELINED;

    <span style="font-weight:bold">END</span> ldap_util_pipelined;
    /
    <span style="font-weight:bold">SHOW</span> ERRORS

    <span style="font-weight:bold">CREATE</span> <span style="font-weight:bold">OR</span> <span style="font-weight:bold">REPLACE</span> PACKAGE BODY ldap_util_pipelined <span style="font-weight:bold">AS</span>

      <span style="font-weight:bold">FUNCTION</span> get_user_groups_nt (p_user VARCHAR2)
      <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_nt PIPELINED <span style="font-weight:bold">IS</span>
        l_groups ldap_util.ldap_groups_nt;
      <span style="font-weight:bold">BEGIN</span>
        l_groups := ldap_util.get_user_groups_nt(p_user);
        <span style="font-weight:bold">FOR</span> i <span style="font-weight:bold">IN</span> 1 .. l_groups.<span style="font-weight:bold">count</span> LOOP
          PIPE <span style="font-weight:bold">ROW</span> (l_groups(i));
        <span style="font-weight:bold">END</span> LOOP;
        <span style="font-weight:bold">RETURN</span>;
      <span style="font-weight:bold">END</span> get_user_groups_nt;

      <span style="font-weight:bold">FUNCTION</span> get_user_groups_aa (p_user VARCHAR2)
      <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_nt PIPELINED <span style="font-weight:bold">IS</span>
        l_groups ldap_util.ldap_groups_aa;
      <span style="font-weight:bold">BEGIN</span>
        l_groups := ldap_util.get_user_groups_aa(p_user);
        <span style="font-weight:bold">FOR</span> i <span style="font-weight:bold">IN</span> 1 .. l_groups.<span style="font-weight:bold">count</span> LOOP
          PIPE <span style="font-weight:bold">ROW</span> (l_groups(i));
        <span style="font-weight:bold">END</span> LOOP;
        <span style="font-weight:bold">RETURN</span>;
      <span style="font-weight:bold">END</span> get_user_groups_aa;

      <span style="font-weight:bold">FUNCTION</span> get_user_groups_va (p_user VARCHAR2)
      <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_va PIPELINED <span style="font-weight:bold">IS</span>
        l_groups ldap_util.ldap_groups_va;
      <span style="font-weight:bold">BEGIN</span>
        l_groups := ldap_util.get_user_groups_va(p_user);
        <span style="font-weight:bold">FOR</span> i <span style="font-weight:bold">IN</span> 1 .. l_groups.<span style="font-weight:bold">count</span> LOOP
          PIPE <span style="font-weight:bold">ROW</span> (l_groups(i));
        <span style="font-weight:bold">END</span> LOOP;
        <span style="font-weight:bold">RETURN</span>;
      <span style="font-weight:bold">END</span> get_user_groups_va;

    <span style="font-weight:bold">END</span> ldap_util_pipelined;
    /
    <span style="font-weight:bold">SHOW</span> ERRORS
</code></pre></div><p>Note the return types of the three functions in ldap_util_pipelined.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">FUNCTION</span> get_user_groups_nt (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_nt PIPELINED;
    <span style="font-weight:bold">FUNCTION</span> get_user_groups_aa (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_nt PIPELINED;
    <span style="font-weight:bold">FUNCTION</span> get_user_groups_va (p_user VARCHAR2) <span style="font-weight:bold">RETURN</span> ldap_util.ldap_groups_va PIPELINED;
</code></pre></div><p>The first two return a nested table collection, while the third returns a VARRAY. These two collections can be pipelined because they correspond to native SQL datatypes in Oracle; not so for associative arrays. In order to pipeline the associative array returned from ldap_util.get_user_groups_aa, we need to map that collection to one of the other types. Here, we map it to a nested table. The iterative logic is the same, though, as the other two functions.</p>
<p>Now we can verify that our approach worked by issuing some simple queries, supported by the SQL &ldquo;TABLE&rdquo; construct.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">SQL</span>&gt; <span style="font-weight:bold">select</span> * <span style="font-weight:bold">from</span> <span style="font-weight:bold">table</span>(ldap_util_pipelined.get_user_groups_nt(<span style="font-style:italic">&#39;jaugusti&#39;</span>));

    CN        DESCRIPTION                                        DISTINGUISHED_NAME                            NAME      SAMACCOUN
    <span style="font-style:italic">--------- -------------------------------------------------- --------------------------------------------- --------- ---------
</span><span style="font-style:italic"></span>    TIMCO_GRP Employees working <span style="font-weight:bold">on</span> the Timco Industries account. CN=TIMCO_GRP,OU=<span style="font-weight:bold">Global</span> Groups,DC=acme,DC=com  TIMCO_GRP TIMCO_GRP
</code></pre></div><p>As you can see, the individual attributes of the record structure form the columns of our new table, and we can reference those columns directly, if we wish.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    <span style="font-weight:bold">SQL</span>&gt; <span style="font-weight:bold">select</span> cn <span style="font-weight:bold">from</span> <span style="font-weight:bold">table</span>(ldap_util_pipelined.get_user_groups_nt(<span style="font-style:italic">&#39;kvongkas&#39;</span>));

    CN
    <span style="font-style:italic">---------------
</span><span style="font-style:italic"></span>    MONEYBROS_GRP
    MONACLE_GRP
    SCHMAPPLE_GRP
</code></pre></div><p>All that&rsquo;s left for us at this point is to construct a WHERE clause condition to use with Oracle&rsquo;s Virtual Private Database feature to limit data returned from queries against the table QUARTERLY_SALES_DATA. That condition could look something like this, assuming that our application connects to the database as the logged in user.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">    client_id <span style="font-weight:bold">IN</span> (<span style="font-weight:bold">SELECT</span> <span style="font-weight:bold">CASE</span> cn
                           <span style="font-weight:bold">WHEN</span> <span style="font-style:italic">&#39;TIMCO_GRP&#39;</span> <span style="font-weight:bold">THEN</span> 100
                           <span style="font-weight:bold">WHEN</span> <span style="font-style:italic">&#39;MONEYBROS_GRP&#39;</span> <span style="font-weight:bold">THEN</span> 200
                           <span style="font-weight:bold">WHEN</span> <span style="font-style:italic">&#39;MONACLE_GRP&#39;</span> <span style="font-weight:bold">THEN</span> 300
                           <span style="font-weight:bold">WHEN</span> <span style="font-style:italic">&#39;SCHMAPPLE_GRP&#39;</span> <span style="font-weight:bold">THEN</span> 400
                         <span style="font-weight:bold">END</span>
                    <span style="font-weight:bold">FROM</span> <span style="font-weight:bold">TABLE</span>(ldap_util_pipelined.get_user_groups_nt(<span style="font-weight:bold">USER</span>)))
</code></pre></div><p>Here the mapping between AD group name and client ID is hardcoded in the CASE expression. A more flexible way would be to create a mapping table. Also, this is probably not a case study in writing a well performing VPD clause, but the real point here is that using SQL table functions and PL/SQL pipelined functions, we can translate data retrieved from an API, LDAP directory, or web service into table-like structures that we can query, join, and otherwise manipulate just like real tables.</p>

  </article>
</section>

  

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>Oracle Database Developer and Performance Tuner, specialized on the Exadata platform. Working for Infolob from Irving, Texas. #OCICertified </p>
      
      
        ¬©
        
        2020
         Toby Marks 
      
      
      
    </section>
  </footer>

    </main>

    

    

    

  </body>

</html>

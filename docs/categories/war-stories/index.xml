<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>War Stories on tobybase.com</title>
    <link>http://localhost:1313/categories/war-stories/index.xml</link>
    <description>Recent content in War Stories on tobybase.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>2015 ~ Toby Marks</copyright>
    <atom:link href="/categories/war-stories/index.xml" rel="self" type="application/rss+xml" />
    
      
        
          <item>
            <title>ODBC Connection Fails for MS Access App on Citrix </title>
            <link>http://localhost:1313/blog/2012/05/11/odbc-connection-fails-for-ms-access-app-on-citrix/</link>
            <pubDate>Fri, 11 May 2012 20:54:00 +0000</pubDate>
            
            <guid>http://localhost:1313/blog/2012/05/11/odbc-connection-fails-for-ms-access-app-on-citrix/</guid>
            <description>&lt;p&gt;I ran into an interesting problem recently when attempting to publish an MS Access application with &lt;a href=&#34;http://www.citrix.com/English/ps2/products/product.asp?contentID=186&amp;amp;ntref=footer&#34;&gt;Citrix XenApp&lt;/a&gt;. The application pulled data from an Oracle database, so an ODBC connection was created on the Citrix server. What we found was that when a non-privileged user tried to run the application, the connection failed. When the Citrix server admin ran it, however, it worked. Furthermore, as long as the admin was logged in, anybody else could run the application successfully; when he logged out, the users&amp;rsquo; connections broke again.&lt;/p&gt;

&lt;p&gt;Since Access is not my area of expertise, we finally contacted Microsoft tech support after trying a few suggestions we dug up in our own research. The support analyst clued us in to the following solution, which I pulled from an Oracle Primavera &lt;a href=&#34;http://docs.oracle.com/cd/E16688_01/Technical_Documentation/Terminal_Services_and_Citrix/Terminal%20Services%20and%20Citrix.pdf&#34;&gt;setup document&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;From what I&amp;rsquo;ve seen on different support forums, this seems to be a pretty standard setup task when running Oracle on Windows over Citrix.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If using an Oracle database platform, confirm [that] the Create Global Objects Windows Security Policy is set up on the Terminal Servers and add the domain Users or Groups of the end-users who will be accessing the published application. If the local security policy is not setup, the following steps can be used to add the policy:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Click Start, Programs, Administrative Tools, and then click Local Security Policy.&lt;/li&gt;
&lt;li&gt;Expand Local Policies, and then click User Rights Assignments.&lt;/li&gt;
&lt;li&gt;In the right pane, double-click Create Global Objects.&lt;/li&gt;
&lt;li&gt;In the Local Security Policy Setting dialogbox, click Add.&lt;/li&gt;
&lt;li&gt;In the Select Users or Group dialog box, select the user group that these end users are a part of, click Add, and then click OK.&lt;/li&gt;
&lt;li&gt;Click OK.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If using an Oracle database platform, the Oracle client software also requires that you give the Authenticated User Group, Read and Execute privilege to the Oracle Home Directory and ALL its sub directories and files on the Terminal Servers.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
          </item>
        
      
    
      
        
          <item>
            <title>Invalidating Toplink Session Cache To Avoid Stale Data</title>
            <link>http://localhost:1313/blog/2012/03/09/invalidating-toplink-session-cache-to-avoid-stale-data/</link>
            <pubDate>Fri, 09 Mar 2012 18:42:00 +0000</pubDate>
            
            <guid>http://localhost:1313/blog/2012/03/09/invalidating-toplink-session-cache-to-avoid-stale-data/</guid>
            <description>&lt;p&gt;Toplink is a Java framework that maps objects to database tables. It is the reference implementation for the Java Persistence Architecture, or JPA. Developers use Toplink to manage data persistence (storage), queries, and transactions in an Oracle database. By default, Toplink makes use of a special cache called a Session Cache, maintained on the server, which is meant to speed up performance. Queried data is stored in the Session Cache and used in subsequent queries to reduce or eliminate calls to the database.&lt;/p&gt;

&lt;p&gt;One problem with this approach is how to deal with &amp;ldquo;stale data&amp;rdquo;. In other words, what happens when data is changing in the database? How does the developer ensure that the cached data is current?&lt;/p&gt;

&lt;p&gt;I ran into this issue recently when consulting with one of our clients on a third-party J2EE application that used Toplink for its persistence layer. What we noticed was that at a certain point in the business process the application was clearly displaying stale data. The &amp;ldquo;status&amp;rdquo; column on a certain record was being changed in the database (as could be verified by a SQL query), but the application still displayed the prior status. Refreshing the screen and requerying the data had no effect. The problem was that the status was being changed through a custom stored procedure which performed direct updates on the screen&amp;rsquo;s underlying table. This approach was technically against the directives of the third-party application vendor, who insisted that all such changes to the database be made via calls to its own web services. That was for good reason. The web services they provided as an API for custom development were the same ones used by the screens to query data. They used the same Toplink Session Cache. Changes made through the web services, therefore, would have updated the cache, thereby avoiding the problem. As it was, the client had unintentionally created out-of-sync scenario between the cache and the database, and the status information displayed on the screen was invalid.&lt;/p&gt;

&lt;p&gt;The most obvious solution would have been to modify the custom procedure to make use of the provided APIs. However, we didn&amp;rsquo;t have an API in this instance that provided exactly the required functionality. Having the software vendor modify or extend the API for our purposes would have been prohibitively expensive, in both time and money.&lt;/p&gt;

&lt;p&gt;Another possibility we considered was to have the vendor make a smaller modification to bypass the Toplink cache for queries on that screen. It is possible to disable caching per table, through the global configuration file persistence.xml, or as a property of an individual query. However, the vendor was not predisposed to introduce what they viewed as a &amp;ldquo;hack&amp;rdquo; to accommodate our custom functionality.&lt;/p&gt;

&lt;p&gt;Ultimately we decided to implement a tacked-on solution that would arrive at the same goal and eliminate the need for an additional iteration through the vendor&amp;rsquo;s dev/test cycle. We created a custom servlet, installed in the third-party application itself, that invalidated the Toplink Session Cache for a specified table or, as an additional method, for all tables. Invalidating the cache means that the next time a query is executed against that table, the Â cache is bypassed and data is retrieved directly from the database. To make it easier for the non-Java in-house developers to use, we created a custom wrapper package to mask the call to the servlet. A call to this package was added to the client&amp;rsquo;s custom code just after the record in question was updated and commited.&lt;/p&gt;

&lt;p&gt;The solution consisted of two Java classes, JAR&amp;rsquo;ed and deployed as a library in the third-party application&amp;rsquo;s WEB-INF/lib directory.&lt;/p&gt;

&lt;p&gt;CacheInvalidator.java&lt;br /&gt;
CacheInvalidatorServlet.java&lt;/p&gt;

&lt;p&gt;The web application configuration file web.xml was also modified to add a reference to the new &amp;ldquo;cacheinvalidator&amp;rdquo; servlet.&lt;/p&gt;

&lt;p&gt;The code was adapted from the following documentation, available on Oracle Tech Net:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/middleware/ias/index-097190.html&#34;&gt;Database Change Notification and TopLink Cache Invalidation&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.oracle.com/technetwork/middleware/ias/index-100679.html&#34;&gt;Oracle TopLink Cache Invalidation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The two methods of CacheInvalidator that do the actual work are shown here. The first takes tablename as an argument, so that the invalidation can be targeted. The second invalidates, or effectively wipes, the entire cache.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #0000aa&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #00aaaa&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #00aa00&#34;&gt;invalidateClass&lt;/span&gt;(Session session, String tableName) &lt;span style=&#34;color: #0000aa&#34;&gt;throws&lt;/span&gt; Exception { 
    &lt;span style=&#34;color: #0000aa&#34;&gt;if&lt;/span&gt;(tableName == &lt;span style=&#34;color: #0000aa&#34;&gt;null&lt;/span&gt; || tableName.&lt;span style=&#34;color: #1e90ff&#34;&gt;trim&lt;/span&gt;().&lt;span style=&#34;color: #1e90ff&#34;&gt;equals&lt;/span&gt;(&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)) { 
        &lt;span style=&#34;color: #0000aa&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color: #0000aa&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;tableName cannot be null&amp;quot;&lt;/span&gt;); 
    } 
    Class baseClass = (Class)tableNameToClass.&lt;span style=&#34;color: #1e90ff&#34;&gt;get&lt;/span&gt;(tableName); 
    &lt;span style=&#34;color: #0000aa&#34;&gt;if&lt;/span&gt;(baseClass == &lt;span style=&#34;color: #0000aa&#34;&gt;null&lt;/span&gt;) { 
        &lt;span style=&#34;color: #0000aa&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color: #0000aa&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;table \&amp;quot;&amp;quot;&lt;/span&gt; + tableName + &lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;\&amp;quot; not found in cache&amp;quot;&lt;/span&gt;); 
    } 
 
    &lt;span style=&#34;color: #aaaaaa; font-style: italic&#34;&gt;// invalidate in TopLink cache the object corresponding to the baseClass &lt;/span&gt;
    session.&lt;span style=&#34;color: #1e90ff&#34;&gt;getIdentityMapAccessor&lt;/span&gt;().&lt;span style=&#34;color: #1e90ff&#34;&gt;invalidateClass&lt;/span&gt;(baseClass); 
} 
 
&lt;span style=&#34;color: #aaaaaa; font-style: italic&#34;&gt;// invalidate all objects in the cache &lt;/span&gt;
&lt;span style=&#34;color: #0000aa&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #00aaaa&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #00aa00&#34;&gt;invalidateAllClasses&lt;/span&gt;(Session session) { 
    &lt;span style=&#34;color: #aaaaaa; font-style: italic&#34;&gt;// invalidate in TopLink cache the object corresponding to the baseClass &lt;/span&gt;
    session.&lt;span style=&#34;color: #1e90ff&#34;&gt;getIdentityMapAccessor&lt;/span&gt;().&lt;span style=&#34;color: #1e90ff&#34;&gt;invalidateAll&lt;/span&gt;(); 
} 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The CacheInvalidatorServlet takes a table name or the special keyword &amp;ldquo;ALL&amp;rdquo; as a parameter and calls the corresponding method in CacheInvalidator.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;String oName = request.&lt;span style=&#34;color: #1e90ff&#34;&gt;getParameter&lt;/span&gt;(&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;objectName&amp;quot;&lt;/span&gt;); 
String responseString = &lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;; 

&lt;span style=&#34;color: #0000aa&#34;&gt;try&lt;/span&gt; { 
    SessionManager manager = SessionManager.&lt;span style=&#34;color: #1e90ff&#34;&gt;getManager&lt;/span&gt;(); 
    &lt;span style=&#34;color: #aaaaaa; font-style: italic&#34;&gt;//SESSIONNAME defined in sessions.xml &lt;/span&gt;
    Server server = (Server)manager.&lt;span style=&#34;color: #1e90ff&#34;&gt;getSession&lt;/span&gt;(&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;SESSIONNAME&amp;quot;&lt;/span&gt;); 
    Session session = server.&lt;span style=&#34;color: #1e90ff&#34;&gt;getActiveSession&lt;/span&gt;(); 

    CacheInvalidator invalidator = &lt;span style=&#34;color: #0000aa&#34;&gt;new&lt;/span&gt; CacheInvalidator(session); 
    &lt;span style=&#34;color: #0000aa&#34;&gt;if&lt;/span&gt; (oName.&lt;span style=&#34;color: #1e90ff&#34;&gt;equals&lt;/span&gt;(&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;ALL&amp;quot;&lt;/span&gt;)) { 
        invalidator.&lt;span style=&#34;color: #1e90ff&#34;&gt;invalidateAllClasses&lt;/span&gt;(session); 
        responseString = &lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;successfully invalidated toplink cache for all tables.&amp;quot;&lt;/span&gt;; 
    } &lt;span style=&#34;color: #0000aa&#34;&gt;else&lt;/span&gt; { 
        invalidator.&lt;span style=&#34;color: #1e90ff&#34;&gt;invalidateClass&lt;/span&gt;(session, oName); 
        responseString = &lt;span style=&#34;color: #aa5500&#34;&gt;&amp;quot;successfully invalidated toplink cache for table: &amp;quot;&lt;/span&gt;+oName; 
    } 
} &lt;span style=&#34;color: #0000aa&#34;&gt;catch&lt;/span&gt; (Exception e) { 
    responseString = e.&lt;span style=&#34;color: #1e90ff&#34;&gt;getMessage&lt;/span&gt;(); 
} 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Calling a servlet from PL/SQL is not particularly complicated, but in our case involved the lookup of server information stored in the database. The wrapper package allowed us to provide the developers with a simple, one-line invocation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;p_servlet_response := utl_http.request(&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;#39;http://&amp;#39;&lt;/span&gt;||l_app_server_host||&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;#39;:&amp;#39;&lt;/span&gt;
          ||l_app_server_port||&lt;span style=&#34;color: #aa5500&#34;&gt;&amp;#39;/jedi/cacheinvalidatorservlet?objectName=&amp;#39;&lt;/span&gt;
          ||p_obj_to_invalidate);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After making a call to our cacheinvalidator package subsequent to updating the status record, the stale data problem was eliminated in the application.&lt;/p&gt;
</description>
          </item>
        
      
    
  </channel>
</rss>
